# APIリクエスト最適化について

## 問題の概要

ウォレットアプリケーションで、Alchemyへのリクエストが予期せず増加する問題が発生しました。

### 発生していた問題
- 1分おきに自動的にリクエストが発生
- 同じデータを何度も取得
- 開発環境でリクエスト数が急増

## 原因

1. **自動ポーリング**
   - ethersライブラリが自動的にブロックチェーンの状態を確認
   - デフォルトで定期的な更新が有効

2. **重複したイベントリスナー**
   - コンポーネントの再レンダリングごとに新しいリスナーが追加
   - 古いリスナーが適切に削除されていない

3. **キャッシュの未使用**
   - 同じデータを何度も取得
   - 短時間での重複リクエスト

## 対策

1. **自動更新の無効化**
   ```typescript
   // プロバイダーの設定を最適化
   provider.polling = false;
   provider.pollingInterval = 0;
   provider.removeAllListeners('block');
   ```

2. **イベントベースの更新**
   - ブロックチェーンの状態が変更された時のみ更新
   - トランザクション発生時のみデータを取得

3. **キャッシュの導入**
   ```typescript
   // 5分間のキャッシュ
   const CACHE_DURATION = 5 * 60 * 1000;
   if (cache && Date.now() - cache.timestamp < CACHE_DURATION) {
     // キャッシュされたデータを使用
   }
   ```

4. **イベントリスナーの最適化**
   - リスナーを一度だけ設定
   - コンポーネントのアンマウント時に適切にクリーンアップ

## 適正なリクエストパターン

### 本来必要なリクエストのタイミング

1. **初期ロード時**
   - ウォレットの初期化時に1回
   - 必要な初期データの取得

2. **トランザクション発生時**
   - 送金や契約の実行時
   - 残高やトランザクション履歴の更新

3. **ユーザーアクション時**
   - 残高確認ボタンのクリック
   - トランザクション履歴の表示要求

### リクエストの種類と適正な頻度

1. **初期化時のみ必要なリクエスト**
   - `eth_chainId`: ネットワーク確認
     - キャッシュ可能
     - 再接続時のみ更新

2. **イベントベースで必要なリクエスト**
   - `eth_blockNumber`: 最新ブロック番号の取得
     - トランザクション発生時
     - 新しいブロック生成時(約12秒ごと)
   - `eth_getLogs`: トランザクション履歴の取得
     - 新規トランザクション発生時
     - 履歴表示要求時
     - 5分間キャッシュ可能

3. **ユーザーアクション時のリクエスト**
   - `eth_getBalance`: 残高確認
     - トランザクション後
     - 明示的な残高確認要求時
     - 5分間キャッシュ可能

### 最適化のポイント

1. **キャッシュ戦略**
   - チェーンID: 永続キャッシュ
   - トランザクション履歴: 5分
   - 残高情報: 5分
   - ブロック情報: 最新のみ

2. **バッチ処理**
   - 複数のリクエストをまとめる
   - 重複を排除
   - エラー時の再試行を制御

3. **イベントフィルタリング**
   - 必要なイベントのみを監視
   - 適切なブロック範囲の指定
   - 不要なポーリングの防止

## 開発環境と本番環境の違い

### 開発環境
- Hot Module Reloadingによる再レンダリング
- コンポーネントの頻繁な再マウント
- デバッグ用の追加リクエスト

### 本番環境
- 必要最小限のリクエスト
- キャッシュの効果的な活用
- イベントベースの更新のみ

## モニタリングのポイント

1. **リクエスト数の監視**
   - 急激な増加がないか
   - 定期的なパターンの有無

2. **レスポンスタイム**
   - 通常は20-50ms程度
   - 異常な遅延の検出

3. **エラーレート**
   - リクエスト失敗の頻度
   - タイムアウトの発生

## まとめ

適切な最適化により、APIリクエストは必要最小限に抑えられ、アプリケーションのパフォーマンスと効率が向上します。ただし、開発環境では様々な要因でリクエスト数が増加する可能性があることに注意が必要です。